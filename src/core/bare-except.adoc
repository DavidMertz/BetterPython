== Bare Or Overly Generic `except` Statements

Mostly for legacy reasons, Python allows the `except` statement to occur in
bare form, without naming specific exceptions to be caught.  This is
categorically a mistake to use. Catching a broad exception where a subclass is
more appropriate is also often a mistake; however, there are gray areas about
exactly how broad an exception it is best to catch, with judgment needed for
each individual decision.

Broadly speaking, when you only identify that "something went wrong" in a
block of code, the remediation you apply can easily fail to match the actual
underlying problem that occurred.  By narrowing exceptions caught to those you
genuinely know how to correct, you express your intentions accurately.  This
is true even when the best action in some exception case is
halt-and-catch-fire; at least you are doing it with deliberation.

Python has a rich exception hierarchy, and most third-party libraries extend
it with additional exceptions specific to their purpose.  As well, numerous
modules in the standard library also extend the built-in exceptions, but do
not expose those unless imported (since you'll only ever see them if you use
that module).

It's easy to see this hierarchy generated by a brief Python program and shown
in Figure 3.1:

.Source code of `code/exception-hierarchy.py`
[source,python]
----
def asciiDocTree(cls, level=1):
    print (f"{'*' * level} {cls.__module__}.{cls.__name__}")
    for i in cls.__subclasses__():
        asciiDocTree(i, level+1)

asciiDocTree(BaseException)
----

I am writing this book in the AsciiDoc format (https://asciidoc.org/), so as a
convenience for myself, I've used its style of nested bullets.  You can easily
modify this code to present a tree with cosmetic differences.  You will notice
that in a few cases, built-in exceptions themselves reference exceptions in
other modules.  In the listing, descendants of `builtins.Exception` are
italicized, which includes most of the hierarchy.

.Hierarchy of built-in exceptions
image::images/Exception-hierarchy.png[]

Suppose that we want to write a program that reads numbers from two files, and
creates a collection that represents the numerator from the first file divided
by the denominator from the second file.  There are a variety of ways that
this program might go wrong.  Many—indeed most—programs you will write have
many potential failure modes.

A naive first attempt might use a _bare except_ (which most linters or style
checkers will already complain about).

.Source code of `code/divide1.py`
[source,python,linenums]
----
#!/usr/bin/env python
import sys
numerators = sys.argv[1]
denominators = sys.argv[2]

try:
    ratios = []
    num_fh = open(numerators)                      # (1)
    den_fh = open(denominators)
    for string_a, string_b in zip(num_fh, den_fh, strict=True):
        a = float(string_a.strip())
        b = float(string_b.strip())
        ratios.append(a/b)
    print(ratios)
except:
    print("Unable to perform divisions")
finally:
    num_fh.close()
    den_fh.close()
----

(1) Another section discusses why a context manager around `open()` might be
better. However, the `finally` will perform cleanup of the open files, and
illustrates this concern better.

Let's run the existing program:

[source,shell]
----
[BetterPython]$ code/divide1.py numerators1.txt denominators1.txt
Unable to perform divisions
----

_Something_ went wrong in the suite of the `try` block.  We have little
information about what kind of problem occured though.  Let's try to get a bit
better visibility by modifying the `except` on line 15-16 above to use:

.Source code of `code/divide2.py` (partial)
[source,python]
----
except Exception as err:
    print(f"Unable to perform divisions:\n    {err}")
    print(f"Partial results: {ratios}")
----

When we run this, we get better insight into what went wrong that is impossible
with a bare `except`.  Let's try running using several different sets of data
files.

[source,shell]
----
[BetterPython]$ code/divide2.py numerators1.txt denominators1.txt
Unable to perform divisions: 
	float division by zero
Partial results: [0.737704, 1.15, 2.0]

[BetterPython]$ code/divide2.py numerators1.txt denominators2.txt
Unable to perform divisions: 
	zip() argument 2 is shorter than argument 1
Partial results: [0.737704, 1.15, 2.0, 0.326086, 0.0]

[BetterPython]$ code/divide2.py numerators1.txt denominators3.txt
Unable to perform divisions: 
	[Errno 13] Permission denied: 'denominators3.txt'
Partial results: []
Traceback (most recent call last):
[...]
NameError: name 'den_fh' is not defined

[BetterPython]$ code/divide2.py numerators1.txt denominators4.txt
Unable to perform divisions: 
	[Errno 2] No such file or directory: 'denominators4.txt'
Partial results: []
Traceback (most recent call last):
[...]
NameError: name 'den_fh' is not defined

[BetterPython]$ code/divide2.py numerators1.txt denominators5.txt
[0.737704, 1.15, 2.0, 0.326086, 0.0, 0.962962]
----

Several different distinct errors occurred.  The program can be made less
fragile by treating each of these errant conditions more specifically.  For
example:

.Source code of `code/divide3.py`
[source,python]
----
#!/usr/bin/env python
import sys

numerators = sys.argv[1]
denominators = sys.argv[2]

try:
    ratios = []
    num_fh = open(numerators)
    den_fh = open(denominators)
    line = 0
    for string_a, string_b in zip(num_fh, den_fh, strict=True):
        line += 1
        a = float(string_a.strip())
        b = float(string_b.strip())
        ratios.append(a / b)
    print([f"{r:.3f}" for r in ratios])
except ZeroDivisionError:
    print(f"Partial results: {[f'{r:.3f}' for r in ratios]}")
    print(f"Attempt to divide by zero at input line {line}")
except ValueError as err:
    print(f"Partial results: {[f'{r:.3f}' for r in ratios]}")
    desc = err.args[0]
    if "zip()" in desc:
        print(desc)
    elif "could not convert" in desc:
        print(f"String is not numeric at input line {line}")
except PermissionError:
    print(f"Partial results: {[f'{r:.3f}' for r in ratios]}")
    print("Insufficient permission to file(s). Run as sudo?")
except FileNotFoundError as err:
    print(f"Partial results: {[f'{r:.3f}' for r in ratios]}")
    print(f"File {err.filename} does not exist")
except OSError as err:
    # Superclass after PermissionError and FileNotFoundError
    print(f"Partial results: {[f'{r:.3f}' for r in ratios]}")
    print(err)
finally:
    try:
        num_fh.close()
        den_fh.close()
    except NameError:
        # Opened in same order as closed, if failure with open()
        # on second, the first file will still get closed here.
        pass
----

Clearly there is a lot more going on in this expanded version.  In a
non-demonstration program, you would probably perform some actual remediation
in the various `except` suites rather than simply print some varying messages
based on the type of error encountered.

One notable feature of the above code is that we catch `PermissionError` and
`FileNotFoundError`, but then also catch their parent class `OSError` _later_
in the sequence of `except` clauses.  We have a specific behavior we want if
those exact things went wrong, but still recognize that there are other ways
that `open()` might fail that we haven't specifically thought about.

In some suites, there might be a final `except Exception` that does generic
logging of "everything that we haven't thought of that could go wrong."  Such
a suite might either decide to continue the rest of the program, or use a bare
`raise` to re-raise the same exception, depending on what served the program
purpose better.

Let's run the new version:

[source,shell]
----
[BetterPython]$ code/divide3.py numerators1.txt denominators1.txt
Partial results: ['0.738', '1.150', '2.000']
Attempt to divide by zero at input line 4

[BetterPython]$ code/divide3.py numerators1.txt denominators2.txt
Partial results: ['0.738', '1.150', '2.000', '0.326', '0.000']
zip() argument 2 is shorter than argument 1

[BetterPython]$ code/divide3.py numerators1.txt denominators3.txt
Partial results: []
Insufficient permission to file(s). Run as sudo?

[BetterPython]$ code/divide3.py numerators1.txt denominators4.txt
Partial results: []
File denominators4.txt does not exist

[BetterPython]$ code/divide3.py numerators1.txt denominators5.txt
['0.738', '1.150', '2.000', '0.326', '0.000', '0.963']
----

I have not bothered to display the contents of the several data files because
those don't really matter. They are all text files with one number listed per
line.  However, do notice that the code considers the case of a line
containing a string that cannot be converted to a `float`.  

Unfortunately, the `zip(strict=True)` and the `float("abc")` cases both raise
`ValueError` rather than more specific subclasses.  We have to tease them
apart inside the `except` suite by looking at the actual messages contained
inside the exception object.  This remains slightly fragile because Python
does not guarantee it will not change the wording of error message between
versions, and we are simply looking for substrings that currently occur inside
those messages.  Actually, even more than not guaranteeing, a conscious effort
is being made to improve the quality of error messages since 3.10; but
"improve" obviously means "change."
